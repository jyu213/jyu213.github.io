<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 见见 - 前端小记</title>
    <link>http://jyu213.github.io/post/</link>
    <description>Recent content in Posts on 见见 - 前端小记</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 01 Apr 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://jyu213.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CSS 模块化组织之道</title>
      <link>http://jyu213.github.io/blog/2017/04/01/css-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%84%E7%BB%87%E4%B9%8B%E9%81%93/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2017/04/01/css-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%84%E7%BB%87%E4%B9%8B%E9%81%93/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;前几天还在问朋友，CSS 近期有没有推出啥比较火热的，答，除了 &lt;code&gt;Grid&lt;/code&gt; 好像没啥新东西。CSS 确实好像没有 JS 社区那么火热了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于 CSS 自身语言的特点，操作起来非常容易，但是等到项目到达一定程度的时候，想要优雅的管理 CSS，却也不见得那么容易。&lt;/p&gt;

&lt;p&gt;大家平常在开发 CSS 的过程中， 肯定遇到过下面的一些情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全局命名空间容易冲突&lt;/li&gt;
&lt;li&gt;文件依赖管理的混乱&lt;/li&gt;
&lt;li&gt;层级嵌套太深&lt;/li&gt;
&lt;li&gt;样式被重置&lt;/li&gt;
&lt;li&gt;大量重复、冗余、无用的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好的 CSS 设计应该具有&lt;strong&gt;可读性&lt;/strong&gt;，&lt;strong&gt;维护性&lt;/strong&gt;，&lt;strong&gt;扩展性&lt;/strong&gt;和&lt;strong&gt;复用性&lt;/strong&gt;。这几条其实也不用特地的去解释，在软件开发设计中并不陌生。大体来说，就是设计 CSS 的时候，我们需要考虑书写的条理是否清晰，后续修改内容是否低成本，新增内容又是否会打破现有逻辑。而在组织 CSS 的时候，尽量地多考虑下抽象与解耦，可以依据现有的内容，快速创建新的模块。&lt;/p&gt;

&lt;p&gt;而现在对于 CSS 模块化的解决方案其实也有很多，比如 &lt;code&gt;OOCSS&lt;/code&gt;，&lt;code&gt;SMACSS&lt;/code&gt;，&lt;code&gt;CSS Modules&lt;/code&gt; 以及 &lt;code&gt;BEM&lt;/code&gt; 的命名规则。在这里，我也不一一介绍这些概念具体是什么了，有兴趣的同学可以自己去研究下，相关的文章已经太多了。&lt;/p&gt;

&lt;p&gt;在如此多的选择之中，甚至可以说是混乱，我觉得最重要的是，各个团队应该依据各自的业务情况选择合适的方案，并做好团队中的&lt;strong&gt;约定&lt;/strong&gt;。大家遵循同一套约定与规范，在合理解决问题的同时也避免出现使用混乱的情况。&lt;/p&gt;

&lt;p&gt;下面来谈谈我自己平时项目中的一些解决方案。这也是平时开发经验和借鉴现有方案的组合。&lt;/p&gt;

&lt;p&gt;闲话扯在前面的是，目前方案中推荐使用预处理器等方式。虽然即使不用也能满足绝大多数场景，但是有更优雅而便捷的方式何乐而不为呢。&lt;/p&gt;

&lt;p&gt;首先，目录划分。将 CSS 分为两类，通用模块和业务模块，可以适当地分为多个小文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通用模块中存放公共部分，同一类别独自一文件，可以是表示结构的，也可以是表示主题的，唯独表示页面具体逻辑的部分，不能放在该目录下。&lt;/li&gt;
&lt;li&gt;业务模块则指具体页面对应的 CSS 文件。一个页面单独对应一个 CSS 文件。通过 &lt;code&gt;@import&lt;/code&gt; 引入相关的通用模块子文件及需要更细粒度拆分的 CSS 文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如下图所示，&lt;code&gt;common&lt;/code&gt; 中存在的为共用部分文件，而 &lt;code&gt;page&lt;/code&gt; 下则具体对应到指定的页面。&lt;code&gt;Demo/style.css&lt;/code&gt; 为对应 &lt;code&gt;Demo&lt;/code&gt; 页面中的 CSS 文件。其中 &lt;code&gt;style.css&lt;/code&gt; 可能还 &lt;code&gt;@import&lt;/code&gt; 了 &lt;code&gt;common/form.css&lt;/code&gt;，&lt;code&gt;common/btn.css&lt;/code&gt; 以及 &lt;code&gt;Demo/css&lt;/code&gt; 目录下的文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ├── common
    │   ├── btn.css
    │   ├── common.css
    │   ├── form.css
    │   └── layout.css
    └── page
        └── Demo
            ├── css
            │   ├── list.css
            │   └── search.css
            └── style.css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次，在命名方式上，主要以原子类 + BEM 的方式来命名。
这里的原子类，不是像 &lt;code&gt;mr10&lt;/code&gt;， &lt;code&gt;pull-right&lt;/code&gt; 这类方式，而是带有固有前缀的命名方式。好处是可以通过命名来快速识别所属位置及功能。比如以 &lt;code&gt;ly-&lt;/code&gt; 前缀来表示和页面布局相关结构，如两栏三栏。再比如 &lt;code&gt;pos-mr10&lt;/code&gt;，&lt;code&gt;pos-fl&lt;/code&gt; ，&lt;code&gt;sty-fiz12&lt;/code&gt;等等。这个可能目前需要团队内约定。&lt;/p&gt;

&lt;p&gt;至于具体到达一个组件级别的时候，直接推荐使用 BEM 方式来维护。BEM 真心强大，虽然初识乱花渐欲迷人眼。BEM 后续再单独拆出来讲吧。&lt;/p&gt;

&lt;p&gt;来看一些代码的片段加强理解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;$orange: #fe7800;

@function Mpercentage($value){
    @return percentage($value/640);
}

// btn.css
.btn-full{
    display: inline-block;
    width: 100%; height: 48px; line-height: 48px;
    text-align: center; font-size: 1.8rem;
}
.btn-inline{
    display: inline-block;
    padding: 0 Mpercentage(60);
    height: 30px; line-height: 30px;
}
.btn-purple{
    color: #fff;
    background: #9a78c8;
}
.btn-white{
    color: #666;
    background: #fff;
}

// login.css
.login-form{
    font-size: 1.4rem;

    &amp;amp;__item{
        position: relative;
        margin-bottom: Mpercentage(20);
    }
    &amp;amp;__item_btn{
        margin-top: Mpercentage(30);
    }
    &amp;amp;__item_tips{
        line-height: 35px; font-size: 1.3rem;
        color: #666;
    }
    &amp;amp;__input{
        display: block;
        padding: 0 3%;
        width: 93%; height: 43px; line-height: 43px;
        font-size: 1.5rem;
        border: 1px solid #dadada;

        &amp;amp;:focus{
            border-color: #baacdf;
        }
        &amp;amp;.form-error{
            border-color: $orange;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，通过函数、组件模块的抽离来实现页面的快速重组。这里其实蛮多都依赖到预处理器的特性了，从而使得 CSS 可以变得更加灵活。&lt;/p&gt;

&lt;p&gt;至此，主要概括起来就是通过文件与命名来解决冲突问题，通过预处理器来解决维护扩展问题。&lt;/p&gt;

&lt;p&gt;那么问题来了，你发现了上述中几个不能满足的场景了么？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>挖一挖 submodule</title>
      <link>http://jyu213.github.io/blog/2016/07/02/%E6%8C%96%E4%B8%80%E6%8C%96-submodule/</link>
      <pubDate>Sat, 02 Jul 2016 14:26:44 +0800</pubDate>
      
      <guid>http://jyu213.github.io/blog/2016/07/02/%E6%8C%96%E4%B8%80%E6%8C%96-submodule/</guid>
      <description>

&lt;p&gt;在很长的一段时间内，对&lt;code&gt;submodule&lt;/code&gt;的概念含糊不清。特别是 &lt;code&gt;submodule&lt;/code&gt; 和 &lt;code&gt;subtree&lt;/code&gt; 这两个的区别。今天正好有时间来理一理。&lt;/p&gt;

&lt;h3 id=&#34;子模块-submodule:3b642809b94e451e9d37df2cf008e2bb&#34;&gt;子模块（submodule）&lt;/h3&gt;

&lt;p&gt;为了解决项目中的依赖问题。使得更加方便的维护与管理。子模块允许你将一个 Git         仓库作为另外一个 Git 仓库的子目录，从而保持相对独立的提交记录。&lt;/p&gt;

&lt;p&gt;子模块有点类似与一个软链。你记录他们当前确切所处的提交，但是不能记录一个子模块的 &lt;code&gt;master&lt;/code&gt; 或者其它符号的引用。在 &lt;code&gt;git&lt;/code&gt; 的存储信息中，&lt;code&gt;submodule&lt;/code&gt; 的属于 &lt;code&gt;160000&lt;/code&gt; 模式，这在Git中是一个特殊模式，基本意思是你将一个提交记录为一个目录项而不是子目录或者文件。&lt;/p&gt;

&lt;h4 id=&#34;用法:3b642809b94e451e9d37df2cf008e2bb&#34;&gt;用法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;submodule&lt;/code&gt; 的使用还是挺方便的。&lt;code&gt;.gitmodules&lt;/code&gt; 文件保存着项目 URL 与已经拉取的本地目录之间的映射。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git submodule add&lt;/code&gt; 来增加新模块，&lt;code&gt;git submodule init&lt;/code&gt; 用于初始化，&lt;code&gt;git submodule update&lt;/code&gt; 用于更新，就是删除的时候不太方便。
而另外一个更新维护子模块的时候也有些繁琐，也常常会出一些坑。&lt;/p&gt;

&lt;h3 id=&#34;挖坑说明:3b642809b94e451e9d37df2cf008e2bb&#34;&gt;挖坑说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当你 &lt;code&gt;pull master&lt;/code&gt; 之后，如果 &lt;code&gt;submodule&lt;/code&gt; 有变更，都需要记得&lt;code&gt;submodule update&lt;/code&gt;一下，不然又会提交旧的信息回去了。这本质上，都是因为它在主&lt;code&gt;master&lt;/code&gt;上都是已 &lt;code&gt;link&lt;/code&gt; 的方式存在。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;submodule&lt;/code&gt; 的时候也有点费劲的其实。当你进入 &lt;code&gt;submodule&lt;/code&gt; 的目录，其实不会切到任何分支，&lt;code&gt;HEAD&lt;/code&gt; 处于游离的状态，所以在改动之前需要 &lt;code&gt;checkout master&lt;/code&gt;，再来改动。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;subtree:3b642809b94e451e9d37df2cf008e2bb&#34;&gt;subtree&lt;/h3&gt;

&lt;p&gt;上面讲了这个多，其实官方推荐使用 &lt;code&gt;subtree&lt;/code&gt; 来代替 &lt;code&gt;submodule&lt;/code&gt;。两者的区分在于，&lt;code&gt;submodule&lt;/code&gt;是把一个 &lt;code&gt;commit&lt;/code&gt; 嵌入到当前项目的子目录中，只相当于一个 &lt;code&gt;Link&lt;/code&gt;，而 &lt;code&gt;subtree&lt;/code&gt; 是合并子项目到当前项目的子目录中，是一个完整项目的拷贝。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;subtree&lt;/code&gt; 除了命令长一点外，还是有挺多优点的。比如&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;clone 的时候不需要 &lt;code&gt;init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有类似的 &lt;code&gt;.gitmodule&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;管理上更加方便一些&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;用法-1:3b642809b94e451e9d37df2cf008e2bb&#34;&gt;用法&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;subtree&lt;/code&gt; 的使用相对复杂一些。这个依旧省略了各种操作的说明。具体翻看 API。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关联：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote add -f &amp;lt;子仓库名&amp;gt; &amp;lt;子仓库地址&amp;gt;
git subtree add --prefix=&amp;lt;子目录名&amp;gt; &amp;lt;子仓库名&amp;gt; &amp;lt;分支&amp;gt; --squash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更新&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git fetch &amp;lt;远程仓库名&amp;gt; &amp;lt;分支&amp;gt;
git subtree pull --prefix=&amp;lt;子目录名&amp;gt; &amp;lt;远程分支&amp;gt; &amp;lt;分支&amp;gt; --squash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推送&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git subtree push --prefix=ai ai master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考文献:3b642809b94e451e9d37df2cf008e2bb&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97&#34;&gt;Git 工具 - 子模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A0%91%E5%90%88%E5%B9%B6&#34;&gt;Git 工具 - 子树合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/31769820/differences-between-git-submodule-and-subtree&#34;&gt;Difference between git submodule and subtree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alistra.ghost.io/2014/11/30/git-subtree-a-better-alternative-to-git-submodule/&#34;&gt;git subtree - a better alternative to git submodule&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CSS哲学伪命题</title>
      <link>http://jyu213.github.io/blog/2016/02/24/css%E5%93%B2%E5%AD%A6%E4%BC%AA%E5%91%BD%E9%A2%98/</link>
      <pubDate>Wed, 24 Feb 2016 00:43:23 +0800</pubDate>
      
      <guid>http://jyu213.github.io/blog/2016/02/24/css%E5%93%B2%E5%AD%A6%E4%BC%AA%E5%91%BD%E9%A2%98/</guid>
      <description>

&lt;p&gt;标题党。这篇文章断断续续的修改过好几次，也没有满意，本来是想总结一下我这些零散的 CSS 知识结构，可能由于知识体系不全面，总是没能把知识点串联成一个通顺的内容。贴出来权当大家一起讨论下“前世今生”。文章后续可能会不定时更新。&lt;/p&gt;

&lt;p&gt;CSS 作为 Web 的基础部分，极其容易上手。但是 CSS 并不算的上是一门编程语言，在语言能力上略显薄弱，往往导致整体的维护性变差。但是这并没有使得大家停止对 CSS 的探索，从命名规范，目录架构，预处理器(如&lt;code&gt;SASS&lt;/code&gt;)，后处理器（&lt;code&gt;PostCSS&lt;/code&gt;），模块化等等的方向上，努力把 CSS 变得更好。&lt;/p&gt;

&lt;h3 id=&#34;关于自我历程:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;关于自我历程&lt;/h3&gt;

&lt;p&gt;其实我自己并没有系统的学习过 CSS（虽然我现在也不知道如何系统的学习），看了几个视频，扫了下中文版的 API，然后就开始了切图生涯，很多的知识点也都是后来一些零散的博客中了解到的。这过程中，的的确确踩过不少的坑，有的填了，有的继续祸害着项目里其它的同学。也导致我在很长的时段时间里都是走在一个混乱无序的 CSS 书写当中。&lt;/p&gt;

&lt;p&gt;最早遇到的大概的是命名的问题了吧，因为本身积累的词汇量就少，动不动就没单词可用了。那个时候好像也就是网上列出一大堆像&lt;code&gt;menu&lt;/code&gt;， &lt;code&gt;siderbar&lt;/code&gt;之类的“命名大全”来模仿。再到后来接触到了 &lt;code&gt;Bootstrap&lt;/code&gt; 这种比较系统的框架（里面有好多可以值得借鉴的地方），而后又看到一些按类别划分文件，再配有特有的前缀的管理方式(那个时候还并不知道 &lt;code&gt;SMACSS&lt;/code&gt; 的名词)，还有一些原子化，把功能和样式分离等等的。在 &lt;code&gt;SASS&lt;/code&gt; 兴起的时候其实挺兴奋的，因为终于感觉有了点编程的能力，当然了，对变量，嵌套，&lt;code&gt;mixins&lt;/code&gt;等等的使用，很大程度上提高了编程效率。在后来同事的分享中，又了解了 BEM 的命名方式（初看很乱，了解后有一种豁然开然的感觉，细细回想起来，也就是大家约定一套共用的命名规范）。以及通过 &lt;code&gt;PostCSS&lt;/code&gt; 去实现 CSS 中一些自动处理的任务。在 React/ES6/Webpack 出现后，使得很大一部分程度上，CSS 写在 JS 中的方式也开始在特定的场合中频频出现。&lt;/p&gt;

&lt;p&gt;以上，通通出现过我的项目中，在项目切换维护的时候，那感觉，心如刀割。并不是说上面涉及到的知识点有对错的问题，只是在一个团队中，如果没有一些统一的架构和约定，往往到项目的后期会变得越来越不稳定。这不禁又让我想起了 CSS 的学习曲线（像PHP？又来黑了），样式大家都能写，能愉快的维护，又是另一个层次了。&lt;/p&gt;

&lt;p&gt;个人觉得 CSS 中有两个比较重要的点，&lt;strong&gt;语义化&lt;/strong&gt;和&lt;strong&gt;可维护性&lt;/strong&gt;，而最终都是为了提高开发的效率。&lt;/p&gt;

&lt;p&gt;语义化很大一部分程度上是为了阅读需要，简易明了。建议团队内还是要尽量的保持风格一致。其它的，可以看一下&lt;a href=&#34;http://www.tychio.net/tech/2015/03/14/thinking-in-semantic-css.html&#34;&gt;CSS语义思维&lt;/a&gt;的内容，这里不展开讲了。&lt;/p&gt;

&lt;p&gt;可维护性真的是一个很虚的概念，但是涉及到了多方面的各个点。比如，该怎么保持项目的简单性，灵活性，而同时又有足够的扩展能力？又比如如何抽取模块，是以功能划分还是以样式结构？如何重用样式？如何防止样式被覆盖，避免冗余代码等等。&lt;/p&gt;

&lt;p&gt;除了一次性的单页面这种外，一般项目类型的，都建议在开始的时候就搭好底层，统一一下整体风格与使用习惯，保持良好组织结构，命名规范，不然越往后面，可能会遇到更大的问题。&lt;/p&gt;

&lt;p&gt;比如，对文件做一个层次划分&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基础框架（reset，iconfont，栅格）&lt;/li&gt;
&lt;li&gt;通用模块（原子，统一规范的模块）&lt;/li&gt;
&lt;li&gt;页面样式（继承通用模块）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;采用类似 &lt;code&gt;BEM/SUIT&lt;/code&gt; 等等的命名方式等等。&lt;/p&gt;

&lt;h3 id=&#34;现有的技术选择:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;现有的技术选择&lt;/h3&gt;

&lt;p&gt;其实我们在平时应该或多或少的接触过一些 &lt;code&gt;SASS&lt;/code&gt;, &lt;code&gt;Compass&lt;/code&gt;, &lt;code&gt;BEM&lt;/code&gt;, &lt;code&gt;SMACSS&lt;/code&gt;, &lt;code&gt;OOCSS&lt;/code&gt; 的概念与设计模式。当然并没有一种解决方案是绝对的，合适当前的项目就可以了。&lt;/p&gt;

&lt;h4 id=&#34;bem:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;BEM&lt;/h4&gt;

&lt;p&gt;用于解决项目命名规则问题。BEM 通过已&lt;code&gt;block(块)&lt;/code&gt;，&lt;code&gt;element(元素)&lt;/code&gt;，&lt;code&gt;modifier(修饰符)&lt;/code&gt; 的概念，使用连接符串联父级块作为前缀，来实现功能模块命名的唯一性。有兴趣的同学可以看一下 &lt;a href=&#34;http://www.w3cplus.com/css/the-history-of-the-bem-methodology.html&#34;&gt;BEM的进化史&lt;/a&gt;。发现一句话并不太好表述清楚，想要具体了解的同学可以移步&lt;a href=&#34;https://en.bem.info/&#34;&gt;官网&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BEM&lt;/code&gt; 这种唯一性以及元素间的平级展开，往往在稍微复杂一点的项目里，就会把名字命名的很长很长。目前也有很多是在 &lt;code&gt;BEM&lt;/code&gt; 的基础上衍生出来的一些方式(如 &lt;code&gt;SUIT&lt;/code&gt;)。&lt;/p&gt;

&lt;h4 id=&#34;oocss-object-oriented-css:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;OOCSS （Object Oriented CSS）&lt;/h4&gt;

&lt;p&gt;面向对象 CSS。是一种已面向对象的维护方式去管理组织 CSS 代码。其哲学理念是模块化，功能单一性，关注点分离。&lt;/p&gt;

&lt;p&gt;OOCSS 中有两个重要的原则&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;结构和外观分离。样式尽量独立，和 DOM 无关&lt;/li&gt;
&lt;li&gt;容器和内容分离。CSS 只关注内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;OOCSS&lt;/code&gt; 与 &lt;code&gt;SASS&lt;/code&gt; 结合是一个不错的选择，充分强大。&lt;/p&gt;

&lt;h4 id=&#34;smacss-scalable-and-modular-architecture-for-css:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;SMACSS(Scalable and Modular Architecture for CSS)&lt;/h4&gt;

&lt;p&gt;可扩展和模块化 CSS。
把 CSS 样式划分为若干个不同类别的文件，如基础，布局，模块，主题等等。在加上一些特有前缀的组合。&lt;/p&gt;

&lt;h4 id=&#34;acss-atomic-css:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;ACSS (Atomic CSS)&lt;/h4&gt;

&lt;p&gt;原子化 CSS。遵循关注点分离原则。&lt;/p&gt;

&lt;h3 id=&#34;css-模块化:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;CSS 模块化&lt;/h3&gt;

&lt;p&gt;随着 &lt;code&gt;React&lt;/code&gt; 的迅速引爆，其它关于 CSS 的另一种使用方式也在兴起。将样式在 JS 中定义。借助 &lt;code&gt;require/import&lt;/code&gt; 而解决了 CSS 中的命名空间的问题，使得单文件变得简单清晰。而通过组合，也可以实现快速的重复利用。甚至有些 CSS 可以单独与组件去绑定。&lt;/p&gt;

&lt;p&gt;以及其它的一些方式。上述的方式，是比较让我眼前一亮的感觉。&lt;/p&gt;

&lt;h3 id=&#34;未来走向:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;未来走向&lt;/h3&gt;

&lt;p&gt;待补充&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;扩展阅读:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;扩展阅读&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://glenmaddern.com/articles/css-modules&#34;&gt;CSS模块&lt;/a&gt;&lt;a href=&#34;http://www.w3cplus.com/css/css-modules.html&#34;&gt;(中文翻译版)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://aliceui.org/docs/rule.html&#34;&gt;CSS 规范和最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3cplus.com/css/the-history-of-the-bem-methodology.html&#34;&gt;BEM 进化史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/21943416&#34;&gt;如何理解 CSS 类名语义化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3cplus.com/css/css-layers.html&#34;&gt;CSS 分层&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Rollup 试炼之路</title>
      <link>http://jyu213.github.io/blog/2016/01/14/rollup-%E8%AF%95%E7%82%BC%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2016/01/14/rollup-%E8%AF%95%E7%82%BC%E4%B9%8B%E8%B7%AF/</guid>
      <description>

&lt;p&gt;最近看到挺多次 Rollup 这个词，再也架不住好奇，简单的学习实践了一下。&lt;a href=&#34;https://github.com/jyu213/rollup-demo&#34;&gt;完整项目库地址请戳&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;PS: ES6 对应 ES2015，请忽略这些细节。&lt;/p&gt;

&lt;h3 id=&#34;什么是-rollup:94a5bc0f1c88307be9ce656c563df6ba&#34;&gt;什么是 Rollup&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rollup/rollup&#34;&gt;Rollup Github 地址&lt;/a&gt;。根据官网的解释，Rollup 是下一代 ES6 模块化工具。ES6 之后，模块化的写法将更加的趋势化，我们会将以前的文件切割成多个的细小模块。那么如何来高效的组织管理这些文件，又有了很多不同的方案。现有的模块化打包已经有如
&lt;code&gt;Browserify&lt;/code&gt; 和 &lt;code&gt;Webpack&lt;/code&gt; ，那为啥还需要一个新的呢？&lt;/p&gt;

&lt;h3 id=&#34;优势在哪:94a5bc0f1c88307be9ce656c563df6ba&#34;&gt;优势在哪&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以生成 AMD，CMD，UMD 甚至 ES6 模块文件。&lt;/li&gt;
&lt;li&gt;Tree-shaking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;tree-shaking&lt;/code&gt;(有知道中文怎么翻译的同学欢迎留言告知一下)，大致意思就是打包的时候会移除未使用到的 ES6 &lt;code&gt;exports&lt;/code&gt;模块。想要更深入的了解 &lt;code&gt;tree-shaking&lt;/code&gt; 的话，可以看下博士的这篇文章&lt;a href=&#34;http://www.2ality.com/2015/12/webpack-tree-shaking.html&#34;&gt;Tree-shaking with webpack 2 and Babel 6&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;话题转回来，Rollup 正是使用了 ES6 的模块特性，所以会使打包后的文件体积更小。如果是 CommonJS 的则需要先通过插件转为 ES6 后处理。&lt;/p&gt;

&lt;p&gt;对了，值得多说一句的是，Rollup 打包后的代码没有 &lt;code&gt;require&lt;/code&gt;，&lt;code&gt;import&lt;/code&gt;的，而是直接插入到文件中。&lt;/p&gt;

&lt;h3 id=&#34;如何引用:94a5bc0f1c88307be9ce656c563df6ba&#34;&gt;如何引用&lt;/h3&gt;

&lt;p&gt;Rollup 支持 CLI 和 JS API 方式，同时提供了一些插件如解决压缩 babel 转换等问题。(PS: 此处讲解采用 API 的方式)&lt;/p&gt;

&lt;p&gt;首先在项目根目录创建 &lt;code&gt;rollup.js&lt;/code&gt; 文件，安装 &lt;code&gt;npm&lt;/code&gt; 的相关依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var rollup = require(&#39;rollup&#39;);
var babel = require(&#39;rollup-plugin-babel&#39;);
var uglify = require(&#39;rollup-plugin-uglify&#39;);

rollup.rollup({
    entry: &#39;src/index.js&#39;,
    plugins: [
        babel({
            exclude: &#39;node_modules/**&#39;,
            presets: [ &amp;quot;es2015-rollup&amp;quot; ]
        }),
        uglify()
    ]
}).then(function(bundle) {
    bundle.write({
        // output format - &#39;amd&#39;, &#39;cjs&#39;, &#39;es6&#39;, &#39;iife&#39;, &#39;umd&#39;
        format: &#39;umd&#39;,
        moduleName: &#39;dqSystem&#39;,
        sourceMap: true,
        dest: &#39;dqSystem.js&#39;
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rollup&lt;/code&gt; 方法可以配置一些入口文件，依赖插件等，返回的是 &lt;code&gt;bundle&lt;/code&gt; 的 &lt;code&gt;Promise&lt;/code&gt; 方法。&lt;code&gt;bundle&lt;/code&gt; 方法中可以配置文件相关参数，同时也可以生成多份版本文件。具体的 API &lt;a href=&#34;https://github.com/rollup/rollup/wiki/JavaScript-API&#34;&gt;参考官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;node rollup.js&lt;/code&gt; 执行打包。另外 Rollup 好像还不支持 &lt;code&gt;watch&lt;/code&gt; 的配置，我采用了 npm-watch 的方式跳过了。&lt;/p&gt;

&lt;h3 id=&#34;采过的坑:94a5bc0f1c88307be9ce656c563df6ba&#34;&gt;采过的坑&lt;/h3&gt;

&lt;p&gt;试用时间不长，且内容比较简单，可能没碰到一些奇怪的点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rollup.js 中可以 &lt;code&gt;catch&lt;/code&gt; 下 &lt;code&gt;error&lt;/code&gt; 方便调试错误&lt;/li&gt;
&lt;li&gt;UMD/IIFE 模式中需要&lt;code&gt;moduleName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rollup 的模块引用只支持 ES6 Module，其他的需要采用 &lt;code&gt;npm&lt;/code&gt; 和 &lt;code&gt;commonjs&lt;/code&gt; 的插件去解决&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;自己yy下:94a5bc0f1c88307be9ce656c563df6ba&#34;&gt;自己YY下&lt;/h3&gt;

&lt;p&gt;不知道拿 Rollup 和 webpack 相比合不合适。我个人还是挺喜欢 webpack 的打包方式的，关键是功能强大，不过相比，配置也巨复杂。而 Rollup 的配置就简单很多了。实验的项目文件不大，所以没看出来两者在压缩体积上是否有明显的差异。Rollup 的&lt;code&gt;tree-shaking&lt;/code&gt;也将会在 webpack2 中支持。所以好像并没有什么一定非它不可的感觉。&lt;/p&gt;

&lt;p&gt;套用朋友说的一句话，“任何产品的生命周期都得看社区的活跃程度”。从 github 的 fock 人数上，还是持有很大的保留意见的，所有我个人可能会在一些小型或者快速项目中做尝试而已。&lt;/p&gt;

&lt;h3 id=&#34;参考文章:94a5bc0f1c88307be9ce656c563df6ba&#34;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rollup/rollup&#34;&gt;Rollup Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.2ality.com/2015/12/webpack-tree-shaking.html&#34;&gt;Tree-shaking with webpack 2 and Babel 6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ES6 - 字符串模板</title>
      <link>http://jyu213.github.io/blog/2015/12/14/es6---%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2015/12/14/es6---%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF/</guid>
      <description>

&lt;h2 id=&#34;es6-字符串模板:806b46e229fc7cf9ebe3737ebb6a0621&#34;&gt;ES6 - 字符串模板&lt;/h2&gt;

&lt;h3 id=&#34;写在前面:806b46e229fc7cf9ebe3737ebb6a0621&#34;&gt;写在前面&lt;/h3&gt;

&lt;p&gt;关于 ES6, 也终于在 2015 年的 7 月 18 号尘埃落定了。虽然说各大浏览器还没有全面的支持，不过这并不妨碍我们一颗想要撸一把的心。在后端，可以使用 Node.js(0.12+)或 io.js, 前端的话，也可以使用&lt;a href=&#34;http://babeljs.io/&#34;&gt;Babel&lt;/a&gt; 或&lt;a href=&#34;https://github.com/google/traceur-compiler#what-is-traceur&#34;&gt;Traceur&lt;/a&gt; 进行语法预转义成 ES5使用 。&lt;/p&gt;

&lt;p&gt;关于该系列（不知道能不能成为一个系列，总是各种懒），会没有规律的挑选一些内容来学习。欢迎大家积极纠错，留言探讨。&lt;/p&gt;

&lt;h3 id=&#34;模板字符串-template-strings:806b46e229fc7cf9ebe3737ebb6a0621&#34;&gt;模板字符串(template strings)&lt;/h3&gt;

&lt;p&gt;ES6 中引进的一种新型的字符串字面量语法 - 模板字符串。书面上来解释，模板字符串是一种能在字符串文本中内嵌表示式的字符串字面量。简单来讲，就是增加了变量功能的字符串。&lt;/p&gt;

&lt;p&gt;先来看一下以前我们对字符串的使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ```
    /**
     * Before ES6 字符串拼接
     */
    var name = &#39;丁香医生&#39;;
    var desc = &#39;丁香医生是面向大众的科普性健康类网站&#39;;
    var html = function(name, desc){
        var tpl = &#39;公司名：&#39; + name + &#39;\n&#39;+
                &#39;简介：&#39;+ desc;
        return tpl;
    }
    ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而现在：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ```
    var html = `公司名：${name}
        简介：${desc}`;
    ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简洁吧。
引一段 MDN 对于模板字符串的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法(${expression})的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而占位符&lt;code&gt;${}&lt;/code&gt;，可以是任意的 js 表达式（函数或者运算），甚至是另一个模板字符串，会将其计算的结果作为字符串输出。如果模板中需要使用&lt;code&gt;$,{&lt;/code&gt;等字符串，则需要进行转义。&lt;/p&gt;

&lt;p&gt;看个例子就明白了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ```
    var x = 1;
    var y = 2;
    `${ x } + ${ y } = ${ x + y}`  // &amp;quot;1 + 2 = 3&amp;quot;
    ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同于普通字符串，模板字符串还可以多行书写，模板字符串中所有的空格，新行，缩进都会原样的输出在生成的字符串中。&lt;/p&gt;

&lt;p&gt;而单纯的模板字符串还存在着很多的局限性。如：
* 不能自动转义特殊的字符串。（这样很容易引起注入攻击）
* 不能很好的和国际化库配合（即不会格式化特定语言的数字，日期，文字等）
* 没有内建循环语法，（甚至连条件语句都不支持， 只可以使用模板套构的方法）&lt;/p&gt;

&lt;h3 id=&#34;标签模板-tagged-template:806b46e229fc7cf9ebe3737ebb6a0621&#34;&gt;标签模板(tagged template)&lt;/h3&gt;

&lt;p&gt;为此，引出了标签模板的概念。标签模板则是在反引号前面引入一个标签（tag）。该标签是一个函数，用于处于定制化模板字符串后返回值。就拿上面对特殊字符串举例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ```
    /**
     * HTML 标签转义
     * @param {Array.&amp;lt;DOMString&amp;gt;} templateData 字符串类型的tokens
     * @param {...} ..vals 表达式占位符的运算结果tokens
     *
     */
    function SaferHTML(templateData) {
      var s = templateData[0];
      for (var i = 1; i &amp;lt; arguments.length; i++) {
        var arg = String(arguments[i]);
        // Escape special characters in the substitution.
        s += arg.replace(/&amp;amp;/g, &amp;quot;&amp;amp;amp;&amp;quot;)
                .replace(/&amp;lt;/g, &amp;quot;&amp;amp;lt;&amp;quot;)
                .replace(/&amp;gt;/g, &amp;quot;&amp;amp;gt;&amp;quot;);
        // Don&#39;t escape special characters in the template.
        s += templateData[i];
      }
      return s;
    }
    // 调用
    var html = SaferHTML`&amp;lt;p&amp;gt;这是关于字符串模板的介绍&amp;lt;/p&amp;gt;`;
    ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签函数会接收多个参数。
* 第一个参数是包含了字符串字面量(即那些没有变量替换的值)的数组
* 后面的参数是已经替换后的变量值&lt;/p&gt;

&lt;p&gt;改一下例子1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ```
    var name = &#39;丁香医生&#39;;
    var desc = &#39;丁香医生是面向大众的科普性健康类网站&#39;;
    tag`公司名：${name}简介：${desc}`
    ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tag 的参数则分别为 [&amp;lsquo;公司名：&amp;rsquo;,&amp;lsquo;简介：&amp;rsquo;], &amp;lsquo;丁香医生&amp;rsquo;, &amp;lsquo;丁香医生是面向大众的科普性健康类网站&amp;rsquo;。&lt;/p&gt;

&lt;p&gt;有了此类方法，就大大的增加了控制的权利。如上面说的国际化库甚至循环语句。&lt;/p&gt;

&lt;h3 id=&#34;浏览器兼容性:806b46e229fc7cf9ebe3737ebb6a0621&#34;&gt;浏览器兼容性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;服务器端， io.js 支持&lt;/li&gt;
&lt;li&gt;浏览器端， FF34+ , chrome 41+&lt;/li&gt;
&lt;li&gt;移动端 IOS 8, Android 4.4&lt;/li&gt;
&lt;li&gt;IE Tech Preview&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;扩展阅读:806b46e229fc7cf9ebe3737ebb6a0621&#34;&gt;扩展阅读&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://es6.ruanyifeng.com/#docs/string&#34;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/updates/2015/01/ES6-Template-Strings&#34;&gt;Getting Literal With ES6 Template Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.2ality.com/2015/01/template-strings-html.html&#34;&gt;HTML templating with ES6 template strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings&#34;&gt;模板字符串 - MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://segmentfault.com/a/1190000002950341&#34;&gt;ES6 Features系列：Template Strings &amp;amp; Tagged Template Strings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ES6 - 解构赋值</title>
      <link>http://jyu213.github.io/blog/2015/12/14/es6---%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2015/12/14/es6---%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</guid>
      <description>

&lt;p&gt;在解释什么是解构赋值前，我们先来看一下， ES5 中对变量的声明和赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var str = &#39;hello word&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左边一个变量名，右边可以是字符串，数组或对象。&lt;/p&gt;

&lt;p&gt;ES6 中增加了一种更为便捷的赋值方式。称为 &lt;strong&gt;Destructuring&lt;/strong&gt; 。好像大家普遍翻译为解构。解构赋值允许我们将数组或对象的属性赋予给任何变量，该变量的定义语法与数组字面量或对象字面量很相似。举个例子可以直观的说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [speak, name] = [&#39;hello&#39;, &#39;destructuring&#39;];
console.log( speak + &#39; &#39; + name ); // hello destructuring
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;数组的解构赋值:4428bcf4a593931f8cb7d23fa484a629&#34;&gt;数组的解构赋值&lt;/h3&gt;

&lt;p&gt;用更加直白的话来描述就是，等号两边保持相同的形式（数组对应数组，对象对应对象），则左边的变量就会被赋予对应的值。如果对应的右边值缺失，缺失部分变量值为 &lt;code&gt;undefined&lt;/code&gt; ,如果右边值多余，依旧能够正常解构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// ES6 中
let arr = [1,2,3,4,5];
let [el1, el2] = [arr];
// 或者
let [el1, el2] = [1,2,3,4,5];
// el1 =&amp;gt; 1, el2 =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解构赋值也是可嵌套的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let value = [1, 2, [3, 4, 5]];
let [el1, el2, [el3, el4]] = value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样可以通过简单地在指定位置省略变量来忽略数组中的某个元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let value = [1, 2, 3, 4, 5];
let [el1, , el3, , el5] = value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更进一步，默认值同样也可以被指定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [firstName = &amp;quot;John&amp;quot;, lastName = &amp;quot;Doe&amp;quot;] = [];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES6中，提供了一种将右侧多余的值以数组的形式赋值给左侧变量的语法——“rest“模式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [head, ...tail] = [1, 2, 3, 4];
console.log(tail);  // [2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当默认值不存在，变量值就等于 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let [missing] = [];
console.log(missing);  // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的数组，指的是部署了 &lt;code&gt;[Iterator](http://www.2ality.com/2015/02/es6-iteration.html)&lt;/code&gt; 接口的数据结构。&lt;/p&gt;

&lt;h3 id=&#34;对象的解构赋值:4428bcf4a593931f8cb7d23fa484a629&#34;&gt;对象的解构赋值&lt;/h3&gt;

&lt;p&gt;和数组的用法相类似，一个主要的不同点是，对象是无次序排列的，所以变量必须和属性名相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let person = {firstName: &amp;quot;John&amp;quot;, lastName: &amp;quot;Doe&amp;quot;};
let {firstName, lastName} = person;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解构另一个特性是，变量 keys 可以使用&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&#34;&gt;计算后的属性名&lt;/a&gt;，但是如果你对这容易混淆的话，不建议使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let person = {firstName: &amp;quot;John&amp;quot;, lastName: &amp;quot;Doe&amp;quot;};
let {firstName: name, lastName} = person;
// `name`变量将会被声明为 `person.firstName` 的值
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数参数的解构赋值:4428bcf4a593931f8cb7d23fa484a629&#34;&gt;函数参数的解构赋值&lt;/h3&gt;

&lt;p&gt;函数的参数也可以解构赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function add({x: 0, y: 0}){
    return x+y;
}
add({1,2}); // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;null-和-undefined:4428bcf4a593931f8cb7d23fa484a629&#34;&gt;null 和 undefined&lt;/h3&gt;

&lt;p&gt;当尝试解构 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的时候会报错。这是因为使用对象赋值模式时，被解构的值必需能够转换成一个对象（object）。大多数的类型都可以转换为一个对象，但null和undefined却并不能被转换。&lt;/p&gt;

&lt;h3 id=&#34;其它:4428bcf4a593931f8cb7d23fa484a629&#34;&gt;其它&lt;/h3&gt;

&lt;p&gt;解构赋值的好处有很多，比如&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个值的交换&lt;/li&gt;
&lt;li&gt;函数参数默认值&lt;/li&gt;
&lt;li&gt;函数返回值&lt;/li&gt;
&lt;li&gt;正则匹配的返回值&lt;/li&gt;
&lt;li&gt;快速处理 JSON 数据&lt;/li&gt;
&lt;li&gt;遍历Map结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ES6 的解构赋值给 JS 的书写带来了很大的便利性，同时也提高了代码的可读性。但是也需要注意一些问题，避免适得其反。
* 关于圆括号的问题，欢迎翻看&lt;a href=&#34;http://es6.ruanyifeng.com/#docs/destructuring#圆括号问题&#34;&gt;阮一峰老师的博客&lt;/a&gt;
* 解构的嵌套尽量不要太深
* 函数有多个返回值时，尽量使用对象解构而不用数组解构，避免出现顺序对应问题
* 已声明过的变量不能用于解构&lt;/p&gt;

&lt;h3 id=&#34;浏览器支持:4428bcf4a593931f8cb7d23fa484a629&#34;&gt;浏览器支持&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://kangax.github.io/compat-table/es6/#destructuring&#34;&gt;http://kangax.github.io/compat-table/es6/#destructuring&lt;/a&gt;
不完全统计：
* IE NO
* FF 38+ (大部分)
* CH/OP NO
* Webkit
* SF 9+, 8部分
* IOS8 部分&lt;/p&gt;

&lt;p&gt;PS: 整理的时候发现以前还保留着这样一份文章，无新，基本参考下述文章内容。仅供学习。&lt;/p&gt;

&lt;h3 id=&#34;参考文章:4428bcf4a593931f8cb7d23fa484a629&#34;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://es6.ruanyifeng.com/#docs/destructuring&#34;&gt;变量的解构赋值 - 阮一峰&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/&#34;&gt;ES6 In Depth: Destructuring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://strongloop.com/strongblog/getting-started-with-javascript-es6-destructuring/&#34;&gt;Getting Started with JavaScript ES6 Destructuring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>跨域那些事</title>
      <link>http://jyu213.github.io/blog/2014/11/30/%E8%B7%A8%E5%9F%9F%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2014/11/30/%E8%B7%A8%E5%9F%9F%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
      <description>

&lt;h3 id=&#34;同源策略:567b036fb92765e1e5410dd7f84e477b&#34;&gt;同源策略&lt;/h3&gt;

&lt;p&gt;javascript 语言在设计之初为了安全考虑，不允许调用其它页面的对象。 跨域是由 javascript 语言安全限制中的同源策略造成的。
&lt;strong&gt;同源策略&lt;/strong&gt;指的是，一段脚本只能读取来自同一来源的窗口和文档的属性，(同一来源指的是&lt;strong&gt;域名&lt;/strong&gt;、&lt;strong&gt;协议&lt;/strong&gt;和&lt;strong&gt;端口号&lt;/strong&gt;的组合)
简单来讲，即不允许同一域名下的不同端口号，不同协议（http,https），不用子域名（www.dxy.cn 和 app.dxy.cn）及域名和域名对应的 ip 也不允许。&lt;/p&gt;

&lt;h3 id=&#34;解决跨域的原理:567b036fb92765e1e5410dd7f84e477b&#34;&gt;解决跨域的原理&lt;/h3&gt;

&lt;p&gt;HTML 中，静态资源是没有跨域限制的。在 HTML DOM 中，script 标签是可以跨域访问服务器上的数据的。所以我们可以手动插入 script 标签等方法来伪造。 不过，有个限制是，服务器返回 内容不能单纯为一个 json 字符串，可定变量或函数实现，如: &lt;code&gt;var json = {&amp;quot;type&amp;quot;:&amp;quot;json&amp;quot;}&lt;/code&gt; 或 &lt;code&gt;json({&amp;quot;type&amp;quot;:&amp;quot;json&amp;quot;})&lt;/code&gt;。jsonp 即采用后者形式。&lt;/p&gt;

&lt;h3 id=&#34;解决方案:567b036fb92765e1e5410dd7f84e477b&#34;&gt;解决方案&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;手动插入&lt;code&gt;script&lt;/code&gt;标签的形式。&lt;/li&gt;
&lt;li&gt;jsonp
&amp;hellip;
它能对老的浏览器也保持支持。 但是，只支持 get 不支持 post 等其它类型的 HTTP 请求。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;跨域资源共享（CORS）
使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求的成功或者失败。
服务器端对于 CORS 的支持，主要通过 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 进行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&#39;get&#39;, &#39;/xx&#39;, true);
xhr.send();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iframe + domain
对于主域相同而子域不同，则可以只用 document.domain 来实现跨域。&lt;/p&gt;

&lt;p&gt;e.g. 在 &lt;code&gt;http://a.com/test.html&lt;/code&gt; 和 &lt;code&gt;http://sub.a.com/test2.html&lt;/code&gt; 中分别加上 &lt;code&gt;document.domain = a.com&lt;/code&gt;，然后 test.html 页面中创建 iframe 来控制iframe的内容文档。&lt;/p&gt;

&lt;p&gt;注意的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;domain 指向的是主域。 （如 a.com ， www.a.com 其实是二级域名）&lt;/li&gt;
&lt;li&gt;document.domain 需设置为自身或更高一级的父域&lt;/li&gt;
&lt;li&gt;浏览器限制2 为，不同域的框架之间是不能进行 js 的交互的(可取到 window对象，但取不到 window 对象的属性和方法,PS: html5中的 postMessage 例外)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;window.name
&lt;code&gt;window.name&lt;/code&gt; 值在不同页面（包括不同域下）加载后依旧存在(当然关闭窗口后就销毁了)。注意的是，window.name 由大小限制，一般为2M。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTML5 window.postMessage&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;隐藏 form, target 指向一个隐藏的 iframe&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>DPI 和 PPI</title>
      <link>http://jyu213.github.io/blog/2014/09/08/dpi-%E5%92%8C-ppi/</link>
      <pubDate>Mon, 08 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2014/09/08/dpi-%E5%92%8C-ppi/</guid>
      <description>

&lt;p&gt;本文所涉及的内容在网上已有很多介绍。可相互借鉴。笔者仅为整理知识体系所用。&lt;/p&gt;

&lt;h3 id=&#34;ppi-pixel-per-inch:b8585493f60c6c7eca55ca69564e380c&#34;&gt;PPI（Pixel Per Inch）&lt;/h3&gt;

&lt;p&gt;图像分辨率所使用的单位。在图像中每英寸所表达的像素数目。&lt;/p&gt;

&lt;h3 id=&#34;dpi-dot-per-inch:b8585493f60c6c7eca55ca69564e380c&#34;&gt;DPI（Dot Per Inch）&lt;/h3&gt;

&lt;p&gt;打印分辨率使用的单位。每英寸所表达的打印点数。&lt;/p&gt;

&lt;h3 id=&#34;像素-pixel:b8585493f60c6c7eca55ca69564e380c&#34;&gt;像素（Pixel）&lt;/h3&gt;

&lt;p&gt;一种用来计算数码影像的单位。&lt;/p&gt;

&lt;h3 id=&#34;分辨率:b8585493f60c6c7eca55ca69564e380c&#34;&gt;分辨率&lt;/h3&gt;

&lt;p&gt;单位长度中，所表达或撷取的像素数目。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DPI用来表示输出设备的输出精度，如打印机，显示器&lt;/li&gt;
&lt;li&gt;DPI表示的是 像点/英寸（每英寸长度上有多少个打印点或像点）&lt;/li&gt;
&lt;li&gt;PPI用来表示输入设备的输入精度，如扫描仪，数码相机&lt;/li&gt;
&lt;li&gt;PPI表示的是　像素/英寸（每英寸长度上有多少个像素）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考资料:b8585493f60c6c7eca55ca69564e380c&#34;&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sebastien-gabriel.com/designers-guide-to-dpi/home&#34;&gt;Designer&amp;rsquo;s guide to DPI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.zhihu.com/question/21220154&#34;&gt;DPI、PPI、DP、PX 的详细计算方法 - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>主流CSS image比较</title>
      <link>http://jyu213.github.io/blog/2014/08/29/%E4%B8%BB%E6%B5%81css-image%E6%AF%94%E8%BE%83/</link>
      <pubDate>Fri, 29 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2014/08/29/%E4%B8%BB%E6%B5%81css-image%E6%AF%94%E8%BE%83/</guid>
      <description>

&lt;p&gt;在还原设计图的时候，难免会碰到一些样式图片的引用。如何来对这些图片做优化呢？本文简单的梳理了一下目前几种比较常用的使用方式。
注：
1. 有更好的方法的话，欢迎补充。
2. 下文未对性能问题做真实的测试，请保持一颗好奇的心，并告诉我们）&lt;/p&gt;

&lt;h3 id=&#34;css-sprite:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;CSS Sprite&lt;/h3&gt;

&lt;p&gt;这是目前使用比较多的方式。也是我个人认为相对最优的一种解决方式。当然，这里的最优指的是特定环境。比如移动客户端，就不一定要这么干。CSS Sprite 是将页面中所使用到的小图片整合到一张大图上去。大家都知道，客户端向服务器发送请求是很有代价的，特别是在移动端，所以，sprite 的提出是为了减少 http 请求数，从而加快页面加载速度。&lt;/p&gt;

&lt;h4 id=&#34;使用方式:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;使用方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;先将小图片整合到一张大图上&lt;/li&gt;
&lt;li&gt;css 引入背景图片&lt;/li&gt;
&lt;li&gt;然后依据图标的位置使用 background-position 进行定位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;使用技巧:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;使用技巧&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;切图的时候就构思拼接好图片（不然后期抓心挠肺的，当然，善用工具的出门右转）&lt;/li&gt;
&lt;li&gt;排序有序，便于后期维护(个人建议图标从上到下排列)。有利于 background-position 定位&lt;/li&gt;
&lt;li&gt;定位时避免使用 right, bottom 等（后期图片尺寸变化后就不一定了好不）&lt;/li&gt;
&lt;li&gt;合理预留空白位置（空太多文件变大，太小引起图标重叠）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;优点:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;优点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;减少 http 请求。（这个是最大的优点）&lt;/li&gt;
&lt;li&gt;对你存在的图片一目了然（不知道这个算不算，如改进版3.0拿到的图哪些图标是之前已存在不需要重新切了的）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;缺点:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;缺点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;图片合并定位费时费力（谁用谁知道啊）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;其它:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;其它&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;github 上有个 &lt;a href=&#34;https://github.com/Ensighten/grunt-spritesmith&#34;&gt;grunt 合并 sprite&lt;/a&gt; 的组件，可以看看&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;image-data-uri:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;image data URI&lt;/h3&gt;

&lt;p&gt;即将图片资源转换为 base64 字符串格式嵌到页面或样式中。这样连图片的请求链接都省了。
如：&lt;/p&gt;

&lt;h4 id=&#34;使用方式-1:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;使用方式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    /** 数据格式 **/
    data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAE1JREFUKJHV0MEOwCAIA9DW7MP983pymUaweluv8IAABJFUJdWonqEeD0/IwwHK8QatsYlGfIhezM9WOc8jSQAoTvMqTzY1u+Z6449gA9r24D4iZ6wwAAAAAElFTkSuQmCC

    /** 样式引用 **/
    .icon{
      width: 30px; height: 30px;
      background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAE1JREFUKJHV0MEOwCAIA9DW7MP983pymUaweluv8IAABJFUJdWonqEeD0/IwwHK8QatsYlGfIhezM9WOc8jSQAoTvMqTzY1u+Z6449gA9r24D4iZ6wwAAAAAElFTkSuQmCC);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;标签语法:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;标签语法：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;data : 取得数据协议&lt;/li&gt;
&lt;li&gt;image/png : 取得数据的协议名称（注意这里也图片资源也可以使用字体等）&lt;/li&gt;
&lt;li&gt;base64 : 数据编码方式&lt;/li&gt;
&lt;li&gt;iVBOR&amp;hellip; : 编码后数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://baike.baidu.com/view/469071.htm&#34;&gt;Base64编码&lt;/a&gt; 自行百度科普吧。&lt;/p&gt;

&lt;h4 id=&#34;优点-1:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;优点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;减少 HTTP 请求&lt;/li&gt;
&lt;li&gt;避免某些文件跨域&lt;/li&gt;
&lt;li&gt;无图片缓存等问题(但是一般 css 也是有缓存的好不好)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;缺点-1:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;缺点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;兼容性 （ IE6,7 不兼容, 可以使用 MHTML 来解决 ）&lt;/li&gt;
&lt;li&gt;浏览器不会缓存该图片（这里是否是这样我存有疑惑，因为好像看上去也是第一次加载的时候慢）&lt;/li&gt;
&lt;li&gt;增加 css 文件大小&lt;/li&gt;
&lt;li&gt;编码成本及维护(展示不直观，目前需手动转换，我暂时不知道自动替换之类的插件)&lt;/li&gt;
&lt;li&gt;之前有看到过篇测评说性能上比 sprite 微弱一些，一时间找不到链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;综合起来，data URI可以使用在
* 图片尺寸很小，使用一条 http 请求有点浪费，如渐变背景框
* 图片在全站大规模使用，且很少被更新的，如 loading 图&lt;/p&gt;

&lt;h4 id=&#34;在线转换工具:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;在线转换工具&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pjhome.net/web/html5/encodeDataUrl.htm&#34;&gt;Encode Data URL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://websemantics.co.uk/online_tools/image_to_data_uri_convertor/&#34;&gt;image to data URI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;更新:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;更新&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/medium/sus&#34;&gt;github 资源 sus 可转换 data URI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;参考资料:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;参考资料&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/data_URIs&#34;&gt;MDN - data URIs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;icon-fonts:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;icon fonts&lt;/h3&gt;

&lt;p&gt;由于移动端设备拥有不同分辨率，PPI 等引起的问题， 常常需要针对不同屏幕分辨率来调整优化，如使用 &lt;code&gt;@2x&lt;/code&gt; 图片， &lt;code&gt;max-width&lt;/code&gt; 限制等。
采用 css @font-face 用来显示 icon 也不失为一种好办法。
因为 icon fonts (字体)是矢量图形，所以不受分辨率的影响，同时可以做到完美缩放；当然，也可使用在 WEB 端。&lt;/p&gt;

&lt;h4 id=&#34;优点-2:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;优点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;文件小&lt;/li&gt;
&lt;li&gt;加载性能好&lt;/li&gt;
&lt;li&gt;支持 css 样式&lt;/li&gt;
&lt;li&gt;IE6/7 下也支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;缺点-2:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;缺点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;样式限制，使用扁平化风格&lt;/li&gt;
&lt;li&gt;移动端还存在不兼容问题 (&lt;a href=&#34;https://docs.google.com/spreadsheet/ccc?key=0Ag5_yGvxpINRdHFYeUJPNnZMWUZKR2ItMEpRTXZPdUE#gid=0&#34;&gt;兼容表，作者不详&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;少量移动设备和 icon fonts 字符编码冲突&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.zjgsq.com/1523.html&#34;&gt;FF和 IE9 下跨域问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/demix/archive/2009/11/28/1612715.html&#34;&gt;性能问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;使用方法:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;使用方法&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;制作字体文件

&lt;ul&gt;
&lt;li&gt;可以利用字体工具手动制作&lt;/li&gt;
&lt;li&gt;也可以利用在线工具自动生成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在 css 中引用，如下&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;引入字体文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @font-face {font-family: &#39;iconfont&#39;;
        src: url(&#39;iconfont.eot&#39;); /* IE9*/
        src: url(&#39;iconfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */
        url(&#39;iconfont.woff&#39;) format(&#39;woff&#39;), /* chrome、firefox */
        url(&#39;iconfont.ttf&#39;) format(&#39;truetype&#39;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
        url(&#39;iconfont.svg#uxiconfont&#39;) format(&#39;svg&#39;); /* iOS 4.1- */
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再定义一个 icon-* 通配我们所有图标的共有 CSS 样式，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [class^=&amp;quot;icon-&amp;quot;], [class*=&amp;quot; icon-&amp;quot;] {
      display: inline-block;
      speak: none
      font-family: &amp;quot;iconfont&amp;quot;;
      font-size: 16px;
      line-height: 1;
      font-style: normal;
      /** 字体图标出现锯齿的问题： */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后是利用 :before 来注入每个 icon 对应的字体编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .icon-bell:before {
      content: &amp;quot;\003432&amp;quot;;
    }
    .icon-search:before {
      content: &amp;quot;\003433&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;资源推荐:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;资源推荐&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.iconfont.cn/&#34;&gt;阿里巴巴矢量图标库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://icomoon.io/&#34;&gt;icnMoon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fortawesome.github.io/Font-Awesome/&#34;&gt;font awesome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;参考资料-1:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;参考资料&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/cn/articles/icons-fonts-as-your-responsive-strategy&#34;&gt;icon fonts 的探析及应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;其它一些想法:3d62bd3930627ecd781a60ae9258c8eb&#34;&gt;其它一些想法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SVG绘图&lt;/li&gt;
&lt;li&gt;HTML5 离线文件&lt;/li&gt;
&lt;li&gt;localStorage 存储&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>移动端Web系列1 --- 初始化</title>
      <link>http://jyu213.github.io/blog/2014/07/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%971-----%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sun, 20 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/2014/07/20/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%971-----%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description></description>
    </item>
    
    <item>
      <title>html5 Notifications API</title>
      <link>http://jyu213.github.io/blog/1/01/01/html5-notifications-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/1/01/01/html5-notifications-api/</guid>
      <description>

&lt;p&gt;html5 Notifications API 出来也有一段时间了，中间规范要点也变动过好几次，也有几个不同版本。目前仍然是 W3C 的工作草案。刚好最近有项目上应用到，故简单整理一下相关内容作为备忘。注： 本文下面讲解的方法为现阶段草案内容，并不排除后期会做变更。&lt;/p&gt;

&lt;h3 id=&#34;定义:5d8658ff9f33a18b9bdbcfb20e1efa8f&#34;&gt;定义&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Web notifications defines an API for end-user notifications. A notification allows alerting the user outside the context of a web page of an occurrence, such as the delivery of email.&lt;/code&gt; 引自&lt;a href=&#34;http://www.w3.org/TR/notifications/&#34;&gt;W3C notifications&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;简单来说，就是web 端的消息提醒功能。最有印象的应该的 web版 gamil 的邮件提醒了吧。当然这个在桌面软件下早已经不陌生了的吧。不过目前好像还是不支持自定义样子之类的，所以在 UI 上各浏览器呈现具有一定的差异。&lt;/p&gt;

&lt;h3 id=&#34;方法:5d8658ff9f33a18b9bdbcfb20e1efa8f&#34;&gt;方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;window&lt;/code&gt;对象提供了一个&lt;code&gt;Notification&lt;/code&gt; 属性。允许我们提供创建一个通知的实例。并且接收两个参数： 包含通知标题（字符串,&lt;strong&gt;必需&lt;/strong&gt;）， 配置对象的参数。&lt;/p&gt;

&lt;p&gt;配置对象参数包含如下：
* &lt;code&gt;body&lt;/code&gt;: 字符串。进一步定义通知的目的
* &lt;code&gt;lang&lt;/code&gt;: 指定通知的语言类型。必须遵守&lt;a href=&#34;http://tools.ietf.org/html/bcp47&#34;&gt; BCP 47 规范&lt;/a&gt;
* &lt;code&gt;dir&lt;/code&gt;: 定义消息文字显示方向。&lt;code&gt;ltr&lt;/code&gt; 或 &lt;code&gt;rtl&lt;/code&gt;
* &lt;code&gt;tag&lt;/code&gt;: 字符串。作为可使用的检索，替换，删除的通知的 ID
* &lt;code&gt;icon&lt;/code&gt;: 图片链接，用于通知的图标&lt;/p&gt;

&lt;p&gt;例如，实例化如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var notify = new Notification(&#39;hello message&#39;, {
            body: &#39;welcome to the notifications API&#39;
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可作为一个通知实例的只读属性。//
&lt;code&gt;Notifications&lt;/code&gt; 对象提供一个 &lt;code&gt;permission&lt;/code&gt; 属性，用于包含表示当前属性对象的字符串。通知只在用户同意该权限的情况下显示。
* &lt;code&gt;denied&lt;/code&gt;: 表示用户拒绝通知
* &lt;code&gt;granted&lt;/code&gt;: 表示用户赋予通知的权限
* &lt;code&gt;default&lt;/code&gt;: 表示用户选择未知&lt;/p&gt;

&lt;p&gt;该 API 还提供两个方法：
* &lt;code&gt;requestPermission()&lt;/code&gt;: 用来请求询问显示通知的权限。
    - 通知对象的方法，接受用户接受或者拒绝权限执行时执行执行的一个回调函数。可选。参数值可为 &lt;code&gt;defined&lt;/code&gt;, &lt;code&gt;granted&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;。
* &lt;code&gt;close()&lt;/code&gt;: 关闭通知。实例对象，不接收任何参数。&lt;/p&gt;

&lt;p&gt;附加的事件处理函数
* &lt;code&gt;onclick&lt;/code&gt;: 当用户点击通知的调用
* &lt;code&gt;onclose&lt;/code&gt;: 一旦用户或者浏览器关闭通知时调用
* &lt;code&gt;onerror&lt;/code&gt;: 当通知出现错误时调用
* &lt;code&gt;onshow&lt;/code&gt;: 当通知出现时调用&lt;/p&gt;

&lt;h3 id=&#34;兼容性:5d8658ff9f33a18b9bdbcfb20e1efa8f&#34;&gt;兼容性&lt;/h3&gt;

&lt;p&gt;目前只有少数浏览器支持该 API。且同一浏览器不同版本下支持的事件方法可能会有差异（规范改动引起）
&lt;a href=&#34;http://caniuse.com/#feat=notifications&#34;&gt;点击查看&lt;/a&gt;浏览器支持情况&lt;/p&gt;

&lt;p&gt;桌面浏览器: Chrome 22 and Firefox 22 and Safari 6+
移动浏览器: Firefox and Blackberry&lt;/p&gt;

&lt;h3 id=&#34;实践:5d8658ff9f33a18b9bdbcfb20e1efa8f&#34;&gt;实践&lt;/h3&gt;

&lt;p&gt;前面啰啰嗦嗦的讲完了 API 中的大概内容后，来看看实际操作中我们该如何。
注：示例代码中并未针对浏览器做各方面兼容。可参看&lt;a href=&#34;http://yangzhuoyu.com/an-introduce-to-html5-notification/&#34;&gt;风车&lt;/a&gt;中做了更多向下兼容。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;由于浏览器的支持情况有差异，所以我们先得判断用户浏览器是否支持该属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var NotifySupport = !!(Notification in window);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;询问获取浏览器通知权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var NotifyPermission = !!(NotifySupport &amp;amp;&amp;amp; Notification.permission === &#39;granted&#39;);
if(NotifySupport){
    if(NotifyPermission){
        window.Notification.requestPermission();
    }
}else{
    console.log(&#39;your Browser is not support the notification!&#39;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建 Notification 实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Notification(&#39;title&#39;, { &#39;body&#39;: &#39;content&#39;});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;其它:5d8658ff9f33a18b9bdbcfb20e1efa8f&#34;&gt;其它&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jyu213/Notify&#34;&gt;view on github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;参考文章:5d8658ff9f33a18b9bdbcfb20e1efa8f&#34;&gt;参考文章&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/TR/notifications/&#34;&gt;W3C Notifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.chromium.org/developers/design-documents/desktop-notifications/api-specification&#34;&gt;Chorme Notifications API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/notification&#34;&gt;MDN Notification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yangzhuoyu.com/an-introduce-to-html5-notification/&#34;&gt;HTML5 Notification 介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>移动端Web系列2 --- 调试</title>
      <link>http://jyu213.github.io/blog/1/01/01/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%972-----%E8%B0%83%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/1/01/01/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%972-----%E8%B0%83%E8%AF%95/</guid>
      <description>

&lt;h3 id=&#34;浏览器调试:2594d53d9336389dbe2fe5dd4d91c2f1&#34;&gt;浏览器调试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;chrome（V35.0.1916.153）
使用chrome deleloper tool模拟移动设备。注意，部分功能还是与真机有差别，所以还是建议开发完成后在真机中看一下效果。
打开方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调出开发者工具（MAC: cmd+opt+i / WIN: F12）&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;show console&lt;/code&gt;（MAC: Esc）&lt;/li&gt;
&lt;li&gt;选择&lt;code&gt;Emulation&lt;/code&gt;，选择需要的device/user Agent等参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Firefox (V30.0)
我平时没用FF开发。部分细节不是特别熟悉。
好像这个没有对手势等的支持。&lt;/p&gt;

&lt;p&gt;打开方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;工具 - Web开发者 - 响应式设计视图&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;safari
Develop - User Agent。
我只在数据线连接  iphone 的调试的时候用的比较多。 这个下面会讲到。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;设备调试:2594d53d9336389dbe2fe5dd4d91c2f1&#34;&gt;设备调试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;IOS设备远程调试（MAC）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IOS中设置safari高级选项中开启Web检查器&lt;/li&gt;
&lt;li&gt;IOS设备通过数据线连接MAC&lt;/li&gt;
&lt;li&gt;IOS safari中打开页面&lt;/li&gt;
&lt;li&gt;打开桌面版Safari，点击开发菜单，选择你调试的设备名，选择调试的网页&lt;/li&gt;
&lt;li&gt;可看到类似Web的调试界面。具体功能再自己琢磨好了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Android设备远程调试（MAC/PC）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开启系统设置中USB调试（开发人员选项）&lt;/li&gt;
&lt;li&gt;开启桌面Chrome设置中的USB调试选项&lt;/li&gt;
&lt;li&gt;手机chrome浏览器中打开相应的网页&lt;/li&gt;
&lt;li&gt;桌面Chrome可看到对应打开的页面选项&lt;/li&gt;
&lt;li&gt;备注： 网上的ADB插件，貌似在最新版本chrome中可以不用的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动设置 UC浏览器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://plus.uc.cn/document/webapp/doc5.html&#34;&gt;参见官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模拟器:2594d53d9336389dbe2fe5dd4d91c2f1&#34;&gt;模拟器&lt;/h3&gt;

&lt;p&gt;没尝试过。&lt;/p&gt;

&lt;h3 id=&#34;其它:2594d53d9336389dbe2fe5dd4d91c2f1&#34;&gt;其它&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;二维码扫描，真机测试。可使用插件生成二维码。&lt;/li&gt;
&lt;li&gt;同网络中，ip地址访问（注意引用资源路径，也需做相应转换）&lt;/li&gt;
&lt;li&gt;weinre,MIHTol等，现在基本不在使用了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;写在最后:2594d53d9336389dbe2fe5dd4d91c2f1&#34;&gt;写在最后&lt;/h3&gt;

&lt;p&gt;还有更高效的方法的，欢迎继续做补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>移动端Web系列3 -- viewport</title>
      <link>http://jyu213.github.io/blog/1/01/01/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%973----viewport/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/1/01/01/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%973----viewport/</guid>
      <description>

&lt;h3 id=&#34;写在前面:5ee377efb05b9b8169dd9fd09ab77653&#34;&gt;写在前面&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;这里就跳过了文档申明知识的介绍了，这么好的机会还不用html5的，你还在等什么？&lt;/li&gt;
&lt;li&gt;概念了解： device pixels and css pixels

&lt;ul&gt;
&lt;li&gt;css像素： 浏览器使用的抽象单位，主要用来在网页上绘制内容&lt;/li&gt;
&lt;li&gt;设备像素： 显示屏幕的最小物理单位，每个 dp 包含自己的颜色、亮度&lt;/li&gt;
&lt;li&gt;css 1px != device 1px&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;概念了解： screen size and window size&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;viewport:5ee377efb05b9b8169dd9fd09ab77653&#34;&gt;viewport&lt;/h3&gt;

&lt;h4 id=&#34;由来:5ee377efb05b9b8169dd9fd09ab77653&#34;&gt;由来&lt;/h4&gt;

&lt;p&gt;由于手机屏幕相对桌面显示器要小很多，传统网页上的设计在手机上的体验会很糟糕，阅读性非常差。
为了让手机也能获得良好的网页浏览体验，Apple 在移动版 Safari 中定义了 viewport meta 标签(如果没记错最早提出的话)，用于创建一个虚拟窗口（layout viewport），这个虚拟窗口的分辨率接近于桌面显示器，Apple 将其定义为980px。然后将虚拟窗口映射到移动设备的屏幕上，按比例缩放并重新渲染网页。&lt;/p&gt;

&lt;h4 id=&#34;划分:5ee377efb05b9b8169dd9fd09ab77653&#34;&gt;划分&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟窗口（layout viewport）
移动浏览器默认情况下把 viewport 设置为一个比较宽的值（防止太窄而在可视区域中显示错乱）。该默认的 viewport 称为 layout viewport。
宽度可通过 Js 获取(基本所有设备都支持)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.documentElement.clientWidth
document.documentElement.clientHeight
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;视觉窗口（visual viewport）
浏览器可视区域大小。可理解为手机物理屏幕。&lt;/p&gt;

&lt;p&gt;宽度可通过 Js 获取(不支持Android2, Opera Mini, UC8)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.innerWidth
window.innerHeight
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ideal viewport
由Peter-Paul Koch提出的一种概念，一个完美适配移动设备的 viewport。&lt;strong&gt;理想状态&lt;/strong&gt;是不需要用户缩放和横向滚动条就能正常查看，显示的文字大小合适，不区分分辨率，屏幕密度等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;meta viewport
移动端默认使用的是 layout viewport ，而我们想要达到类似 ideal viewport 的效果的话，可以通过 meta 标签来对 viewport 进行控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;移动开发中必出场的定义&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来实现 ideal viewport 的效果。&lt;/p&gt;

&lt;p&gt;meta viewport 标签属性说明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width: 320 // 设置 layout viewport 的宽度，device-width 为设备宽度
height: 800 // 和 width 对应，一般很少用
initial-scale: 1 // 设置页面初始缩放值，
minimum-scale: 1 // 允许用户的最小缩放值
maximum-scale: 1 // 允许用户的最大缩放值
user-scalable: yes/no // 是否允可以手动缩放
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于 meta viewport 的各属性还有很多有趣的知识点。视频中可以揭晓~&lt;/p&gt;

&lt;h3 id=&#34;tips:5ee377efb05b9b8169dd9fd09ab77653&#34;&gt;Tips&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;device-width 查询的是设备像素&lt;/li&gt;
&lt;li&gt;不同浏览器的默认 layout viewport 略有不同&lt;/li&gt;
&lt;li&gt;事件坐标在移动端各种不兼容&lt;/li&gt;
&lt;li&gt;initial-scale 和 device-width 叠加才能兼容目前的移动设备viewport 匹配&lt;/li&gt;
&lt;li&gt;缩放值越大，当前 viewport 的宽度就越小，但是，并不是所有设备都能支持 initial-scale=2 的&lt;/li&gt;
&lt;li&gt;当前缩放值 = ideal viewport 宽度  / visual viewport 宽度&lt;/li&gt;
&lt;li&gt;当设置宽度值冲突时，浏览器会选择最大值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考文献:5ee377efb05b9b8169dd9fd09ab77653&#34;&gt;参考文献&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag&#34;&gt;Mozilla viewport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/docs/insights/ConfigureViewport&#34;&gt;Google Developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quirksmode.org/mobile/viewports.html&#34;&gt;ppk - viewport1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quirksmode.org/mobile/viewports2.html&#34;&gt;ppk - viewport2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.quirksmode.org/mobile/metaviewport/&#34;&gt;ppk - viewport3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://youtu.be/8J6EdpXdzqc&#34;&gt;ppk 大神的视频&lt;/a&gt;，建议看看。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>移动端Web系列4 -- meta</title>
      <link>http://jyu213.github.io/blog/1/01/01/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%974----meta/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jyu213.github.io/blog/1/01/01/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E7%B3%BB%E5%88%974----meta/</guid>
      <description>

&lt;h2 id=&#34;分类:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;分类&lt;/h2&gt;

&lt;p&gt;在介绍移动端特有 meta 标签之前，先简单说一下 HTML meta 标签的一些知识。
meta 标签包含了 &lt;strong&gt;HTTP 标题信息&lt;/strong&gt;(http-equiv) 和&lt;strong&gt;页面描述信息&lt;/strong&gt;(name)。
* http-equiv:
    该枚举的属性定义，可以改变服务器和用户代理行为的编译。编译的值取content 里的内容。简单来说即可以模拟 HTTP 协议响应头。
    最常见的大概属于&lt;code&gt;Content-Type&lt;/code&gt;了，设置编码类型。如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;

H5中可以简化为

    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;


http-equiv常见还有其它如下等（合理使用可增加 SEO 收录）。
- Content-Language : 设置网页语言
- Refresh : 指定时间刷新页面
- set-cookie : 设定页面 cookie 过期时间
- last-modified : 页面最后生成时间
- expires : 设置 cache 过期时间
- cache-control : 设置文档的缓存机制
- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;name:
该属性定义了文档级元数据的名称。用于对应网页内容，便于搜索引擎查找分类，如 keywords, description; 也可以使用浏览器厂商自定义的 meta， 如 viewport；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;移动端特有属性:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;移动端特有属性&lt;/h3&gt;

&lt;h4 id=&#34;viewport:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;viewport&lt;/h4&gt;

&lt;p&gt;可视区域的定义，如屏幕缩放等。告诉浏览器如何规范的渲染网页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上一章节中已经详细讲解过了，这边就不再重复了。&lt;/p&gt;

&lt;h4 id=&#34;format-detection:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;format-detection&lt;/h4&gt;

&lt;p&gt;对电话号码的识别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;meta name=&amp;quot;format-detection&amp;quot; content=&amp;quot;telphone=no&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ios私有属性:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;IOS私有属性&lt;/h3&gt;

&lt;h4 id=&#34;apple-mobile-web-app-capable:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;apple-mobile-web-app-capable&lt;/h4&gt;

&lt;p&gt;启用 webapp 模式, 会隐藏工具栏和菜单栏，和其它配合使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;meta name=&amp;quot;apple-mobile-web-app-capable&amp;quot; content=&amp;quot;yes&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;apple-mobile-web-app-status-bar-style:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;apple-mobile-web-app-status-bar-style&lt;/h4&gt;

&lt;p&gt;在webapp模式下，改变顶部状态条的颜色。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;meta name=&amp;quot;apple-mobile-web-app-status-bar-style&amp;quot; content=&amp;quot;black&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;default(白色，默认) | black(黑色) | black-translucent(半透明)
注意：若值为“black-translucent”将会占据页面位置，浮在页面上方（会覆盖页面 20px 高度， Retina 屏幕为 40px ）。&lt;/p&gt;

&lt;h3 id=&#34;webapp对应的link标签:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;webapp对应的Link标签&lt;/h3&gt;

&lt;h4 id=&#34;apple-touch-icon:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;apple-touch-icon&lt;/h4&gt;

&lt;p&gt;在webapp下，指定放置主屏幕上 icon 文件路径;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;apple-touch-icon&amp;quot; href=&amp;quot;touch-icon-iphone.png&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;apple-touch-icon&amp;quot; sizes=&amp;quot;76x76&amp;quot; href=&amp;quot;touch-icon-ipad.png&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;apple-touch-icon&amp;quot; sizes=&amp;quot;120x120&amp;quot; href=&amp;quot;touch-icon-iphone-retina.png&amp;quot;&amp;gt;
&amp;lt;link rel=&amp;quot;apple-touch-icon&amp;quot; sizes=&amp;quot;152x152&amp;quot; href=&amp;quot;touch-icon-ipad-retina.png&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认 iphone 大小为 60px, ipad 为 76px, retina 屏乘2；
如没有一致尺寸的图标，会优先选择比推荐尺寸大，但是最接近推荐尺寸的图标。
ios7以前系统默认会对图标添加特效（圆角及高光），如果不希望系统添加特效，则可以用apple-touch-icon-precomposed.png代替apple-touch-icon.png&lt;/p&gt;

&lt;h4 id=&#34;apple-touch-startup-image:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;apple-touch-startup-image&lt;/h4&gt;

&lt;p&gt;在 webapp 下，设置启动时候的界面;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;link rel=&amp;quot;apple-touch-startup-image&amp;quot; href=&amp;quot;/startup.png&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不支持 size 属性，可以使用 media query 来控制。iphone 和 touch 上，图片大小必须是 230*480 px,只支持竖屏;&lt;/p&gt;

&lt;h3 id=&#34;其它meta:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;其它meta&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 启用360浏览器的极速模式(webkit) --&amp;gt;
&amp;lt;meta name=&amp;quot;renderer&amp;quot; content=&amp;quot;webkit&amp;quot;&amp;gt;
&amp;lt;!-- 避免IE使用兼容模式 --&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
&amp;lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&amp;gt;
&amp;lt;meta name=&amp;quot;HandheldFriendly&amp;quot; content=&amp;quot;true&amp;quot;&amp;gt;
&amp;lt;!-- 微软的老式浏览器 --&amp;gt;
&amp;lt;meta name=&amp;quot;MobileOptimized&amp;quot; content=&amp;quot;320&amp;quot;&amp;gt;
&amp;lt;!-- uc强制竖屏 --&amp;gt;
&amp;lt;meta name=&amp;quot;screen-orientation&amp;quot; content=&amp;quot;portrait&amp;quot;&amp;gt;
&amp;lt;!-- QQ强制竖屏 --&amp;gt;
&amp;lt;meta name=&amp;quot;x5-orientation&amp;quot; content=&amp;quot;portrait&amp;quot;&amp;gt;
&amp;lt;!-- UC强制全屏 --&amp;gt;
&amp;lt;meta name=&amp;quot;full-screen&amp;quot; content=&amp;quot;yes&amp;quot;&amp;gt;
&amp;lt;!-- QQ强制全屏 --&amp;gt;
&amp;lt;meta name=&amp;quot;x5-fullscreen&amp;quot; content=&amp;quot;true&amp;quot;&amp;gt;
&amp;lt;!-- UC应用模式 --&amp;gt;
&amp;lt;meta name=&amp;quot;browsermode&amp;quot; content=&amp;quot;application&amp;quot;&amp;gt;
&amp;lt;!-- QQ应用模式 --&amp;gt;
&amp;lt;meta name=&amp;quot;x5-page-mode&amp;quot; content=&amp;quot;app&amp;quot;&amp;gt;
&amp;lt;!-- windows phone 点击无高光 --&amp;gt;
&amp;lt;meta name=&amp;quot;msapplication-tap-highlight&amp;quot; content=&amp;quot;no&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.w3cplus.com/mobile/mobile-terminal-refactoring-create-page.html&#34;&gt;参见w3cplus&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;末尾总结:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;末尾总结&lt;/h3&gt;

&lt;p&gt;所以，一般新建页面的时候，可以采用如下结构， 再依据自己的实际需要添加所需即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;apple-mobile-web-app-capable&amp;quot; content=&amp;quot;yes&amp;quot; /&amp;gt;
    &amp;lt;meta name=&amp;quot;format-detection&amp;quot;content=&amp;quot;telephone=no&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!-- code here --&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文献参考:4e435b7af9c4b4216c2cd567c2e774c2&#34;&gt;文献参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&#34;&gt;MDN meta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/safari/documentation/appleapplications/reference/SafariHTMLRef/Articles/MetaTags.html&#34;&gt;苹果官方 webapp meta 说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/Library/ios/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html&#34;&gt;IOS Configuring Web Applications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3cplus.com/mobile/mobile-terminal-refactoring-create-page.html&#34;&gt;移动端重构系列2——新建空白页面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
